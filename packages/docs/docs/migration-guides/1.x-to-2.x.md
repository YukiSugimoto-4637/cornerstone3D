---
id: 2x
title: '1.x to 2.x'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Here are the breaking changes from the cornerstone 1.x to 2.x.

At first glance, it may seem that many files have been changed, with almost all files affected. However, it's important to note that most changes involve fixing import types and removing dependency cycles. Let's examine these changes in more detail below.

![alt text](../../assets/diff-sample.png)

We've addressed and documented all changes, but if you notice any undocumented modifications in the migration guides, please create a pull request to add them.

# General

## Typescript Version

We have upgraded the typescript version from 4.6 to 5.5 in the 2.0 version of the cornerstone3D.
This upgrade most likely don't require any changes in your codebase, but it is recommended to update the typescript version in your project to 5.5
to avoid any issues in the future.

<details>
<summary>Why?</summary>

The upgrade to TypeScript 5.4 allows us to leverage the latest features and improvements offered by the TypeScript standard. You can read more about it here: https://devblogs.microsoft.com/typescript/announcing-typescript-5-5/

</details>

## ECMAScript Target

In Cornerstone3D version 1.x, we targeted ES5. With the release of version 2.0, we have updated our target to `ES2022`.

<details>
<summary>Why?</summary>

It will result in a smaller bundle size and improved performance. There is a good chance that your setup already supports ES2022:

https://compat-table.github.io/compat-table/es2016plus/

</details>

## Remove of CJS, only ESM builds

Starting with Cornerstone3D 2.x, we will no longer ship the CommonJS (CJS) build of the library. You most likely won't need to make any changes to your codebase. If you are aliasing the cjs library in your bundler, you can remove it completely.

<details>
<summary>Why?</summary>
Both Node.js and modern browsers now support ECMAScript Modules (ESM) by default. However, in the rare case where you need a non-ESM version, you can use the Universal Module Definition (UMD) build of the library.
</details>

## Package Exports

The Cornerstone libraries now utilize the `exports` field in their `package.json` files. This allows for more precise control over how modules are imported and ensures compatibility with different build systems.

Below are examples of how to import modules from each package, along with explanations of the `exports` field configuration.

<details>
<summary><b>@cornerstonejs/adapters</b></summary>

```json
{
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "types": "./dist/esm/index.d.ts"
    },
    "./cornerstone": {
      "import": "./dist/esm/adapters/Cornerstone/index.js",
      "types": "./dist/esm/adapters/Cornerstone/index.d.ts"
    },
    "./cornerstone/*": {
      "import": "./dist/esm/adapters/Cornerstone/*.js",
      "types": "./dist/esm/adapters/Cornerstone/*.d.ts"
    },
    "./cornerstone3D": {
      "import": "./dist/esm/adapters/Cornerstone3D/index.js",
      "types": "./dist/esm/adapters/Cornerstone3D/index.d.ts"
    },
    "./cornerstone3D/*": {
      "import": "./dist/esm/adapters/Cornerstone3D/*.js",
      "types": "./dist/esm/adapters/Cornerstone3D/*.d.ts"
    },
    "./enums": {
      "import": "./dist/esm/adapters/enums/index.js",
      "types": "./dist/esm/adapters/enums/index.d.ts"
    }
    // ... other exports
  }
}
```

**Import Examples:**

```js
import * as cornerstoneAdapters from '@cornerstonejs/adapters'; // Imports the main entry point
import * as cornerstoneAdapter from '@cornerstonejs/adapters/cornerstone'; // Imports the Cornerstone adapter
import { someModule } from '@cornerstonejs/adapters/cornerstone/someModule'; // Imports a specific module from the Cornerstone adapter
import * as cornerstone3DAdapter from '@cornerstonejs/adapters/cornerstone3D'; // Imports the Cornerstone3D adapter
// ... other imports
```

</details>

<details>
<summary><b>@cornerstonejs/core</b></summary>

```json
{
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "types": "./dist/esm/index.d.ts"
    },
    "./utilities": {
      // Subpath export
      "import": "./dist/esm/utilities/index.js",
      "types": "./dist/esm/utilities/index.d.ts"
    },
    "./utilities/*": {
      // Wildcard subpath export
      "import": "./dist/esm/utilities/*.js",
      "types": "./dist/esm/utilities/*.d.ts"
    }
    // ... other exports
  }
}
```

**Import Examples:**

```js
import * as cornerstoneCore from '@cornerstonejs/core'; // Imports the main entry point
import * as utilities from '@cornerstonejs/core/utilities'; // Imports the utilities module
import { someUtility } from '@cornerstonejs/core/utilities/someUtility'; // Imports a specific utility
// ... other imports
```

</details>

<details>
<summary><b>@cornerstonejs/tools</b></summary>

```json
{
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "types": "./dist/esm/index.d.ts"
    },
    "./tools": {
      // Subpath export for tools
      "import": "./dist/esm/tools/index.js",
      "types": "./dist/esm/tools/index.d.ts"
    },
    "./tools/*": {
      // Wildcard subpath export for tools
      "import": "./dist/esm/tools/*.js",
      "types": "./dist/esm/tools/*.d.ts"
    }
    // ... other exports
  }
}
```

**Import Examples:**

```js
import * as cornerstoneTools from '@cornerstonejs/tools'; // Imports the main entry point
import * as tools from '@cornerstonejs/tools/tools'; // Imports the tools module
import { someTool } from '@cornerstonejs/tools/tools/someTool'; // Imports a specific tool
// ... other imports
```

</details>

<details>
<summary><b>@cornerstonejs/dicom-image-loader</b></summary>

```json
{
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "types": "./dist/esm/index.d.ts"
    },
    "./umd": {
      // UMD bundle export
      "import": "./dist/dynamic-import/cornerstoneDICOMImageLoader.min.js"
    },
    "./imageLoader": {
      // Subpath export for the image loader
      "import": "./dist/esm/imageLoader/index.js",
      "types": "./dist/esm/imageLoader/index.d.ts"
    }
    // ... other exports
  }
}
```

**Import Examples:**

```js
import * as dicomImageLoader from '@cornerstonejs/dicom-image-loader'; // Imports the main entry point
import * as imageLoader from '@cornerstonejs/dicom-image-loader/imageLoader'; // Imports the imageLoader module specifically
// ... other imports
```

</details>

### cloneDeep

The `structuredClone` function has replaced the previous method. You don't need to make any changes to your codebase that uses Cornerstone3D.

<details>
<summary>Why?</summary>
Why to depend on a third-party library when we can use the native browser API?

</details>

---

## <!-- //////////////////////////////////////// //////////////////// //////////////////// //////////////////// ////////////////////   -->

# @cornerstonejs/streaming-image-volume-loader

After years of development on Cornerstone3D, we recognized that volume loading should be treated as a first-class feature rather than a separate library. As a result, we have merged all functionality related to streaming image loading into the core library.

1. **Removal of Separate Library**: The `@cornerstonejs/streaming-image-volume-loader` package has been removed.
2. **Integration into Core**: All streaming image volume loading functionality is now part of the `@cornerstonejs/core` package.

## How to Migrate:

If you were previously using `@cornerstonejs/streaming-image-volume-loader`, you'll need to update your imports and potentially adjust your code to use the new integrated volume loading API in `@cornerstonejs/core`.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
import {
  cornerstoneStreamingImageVolumeLoader,
  cornerstoneStreamingDynamicImageVolumeLoader,
  StreamingImageVolume,
  StreamingDynamicImageVolume,
  helpers,
  Enums,
} from '@cornerstonejs/streaming-image-volume-loader';

Enums.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED;
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
import {
  cornerstoneStreamingImageVolumeLoader,
  cornerstoneStreamingDynamicImageVolumeLoader,
  StreamingImageVolume,
  StreamingDynamicImageVolume,
} from '@cornerstonejs/core';

import { getDynamicVolumeInfo } from '@cornerstonejs/core/utilities';
import { Enums } from '@cornerstonejs/core/enums';

Enums.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED;
```

  </TabItem>
</Tabs>

---

## <!-- //////////////////////////////////////// //////////////////// //////////////////// //////////////////// ////////////////////   -->

# @cornerstonejs/core

## Initialization

### Removal of `detect-gpu` and `detectGPUConfig`

Cornerstone3D 2.x has removed the dependency on `detect-gpu`. This change addresses issues reported by users working in environments where internet access is restricted, as `detect-gpu` relied on internet connectivity to determine GPU models.

#### Key Changes:

1. **Default GPU Tier**: We now use a default GPU tier of 2 (medium tier).
2. **No Internet Dependency**: The library no longer requires internet access for GPU detection.
3. **Configurable GPU Tier**: You can still configure your own GPU tier if needed.

#### How to Migrate:

If you were previously relying on `detect-gpu` for GPU tier detection, you'll need to update your initialization code. Here's an example of how to initialize Cornerstone3D with a custom GPU tier:

```js
cornerstone3D.init({ gpuTier: 3 });
```

### removal of `use16BitDataType`

This flag requested 16-bit data type from the web worker. Now, we always use the native data type for cache storage and convert it for rendering when necessary.

### removal of `enableCacheOptimization`

It is no longer needed since we automatically optimize cache for you.

## Volume Viewports Actor UID, ReferenceId, and VolumeId

### Previous Behavior

When adding a volume to volume viewports, the logic used to determine the actor's UID was as follows:

```js
const uid = actorUID || volumeId;
volumeActors.push({
  uid,
  actor,
  slabThickness,
  referenceId: volumeId,
});
```

In this setup, the actor UID and `referenceId` were both set to the `volumeId`. This was problematic because it created actors with identical UIDs, even when they should have been unique. Throughout the codebase, we relied on `actor.uid` to retrieve volumes from the cache, which added further confusion.

### Updated Behavior

Weâ€™ve made the following changes to improve clarity and functionality. The actor UID is now distinct, using this logic:

```js
const uid = actorUID || uuidv4();
volumeActors.push({
  uid,
  actor,
  slabThickness,
  referencedId: volumeId,
});
```

### Key Changes

1. **Unique Actor UID**: The actor UID is now always a unique identifier (`uuidv4()`), while the `referencedId` is set to the `volumeId`. If your code relied on `actor.uid` to retrieve volumes, you should now use `referencedId` or the new `viewport.getVolumeId()` method to get the `volumeId`â€”which is the preferred approach.

2. **Renaming `referenceId` to `referencedId`**: To improve clarity, `referenceId` has been renamed to `referencedId`. This change aligns with our libraryâ€™s naming conventions, such as `referencedImageId` and `referencedVolumeId`. Since an actor can be derived from either a volume or an image, using the term `referencedId` provides a more accurate description of its role.

These changes should make the logic easier to follow and prevent issues with duplicate UIDs.

### Migrations

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
const defaultActor = viewport.getDefaultActor();
const volumeId = defaultActor.uid;
const volume = cache.getVolume(volumeId);
```

or

```js
volumeId = viewport.getDefaultActor()?.uid;
cache.getVolume(volumeId)?.metadata.Modality;
```

or

```js
const { uid: volumeId } = viewport.getDefaultActor();
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
const volume = cache.getVolume(viewport.getVolumeId());
```

  </TabItem>
</Tabs>

## Viewport APIs

### ImageDataMetaData

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
interface ImageDataMetaData {
  // ... other properties
  numComps: number;
  // ... other properties
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
export interface ImageDataMetaData {
  // ... other properties
  numberOfComponents: number;
  // ... other properties
}
```

  </TabItem>
</Tabs>

### Reset Camera

Previously, we had a `resetCamera` method that took positional arguments. Now it takes an object argument.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
viewport.resetCamera(false, true, false);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
viewport.resetCamera({
  resetZoom: true,
  resetPan: false,
  resetToCenter: false,
});
```

  </TabItem>
</Tabs>

### Rotation

The `rotation` property has been removed from `getProperties` and `setProperties`, and has moved to `getViewPresentation` and `setViewPresentation` or `getCamera` and `setCamera`.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
viewport.getProperties().rotation;
viewport.setProperties({ rotation: 10 });
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
const { rotation } = viewport.getViewPresentation();

// or

const { rotation } = viewport.getCamera();

viewport.setViewPresentation({ rotation: 10 });

// or

viewport.setCamera({ rotation: 10 });
```

  </TabItem>
</Tabs>

<details>
<summary>Why?</summary>

`rotation` is not a property of the viewport but rather a view prop. You can now access it through `getViewPresentation`.

</details>

### getReferenceId

`getReferenceId` is now `getViewReferenceId`

```js
viewport.getReferenceId() -- > viewport.getViewReferenceId();
```

<details>
<summary>Why?</summary>

It is more accurate to use `getViewReferenceId` to reflect the actual function of the method since it returns view-specific information, and not about the actor reference.

</details>

## New PixelData Model and VoxelManager

The Cornerstone library has undergone significant changes in how it handles image volumes and texture management. These changes aim to improve performance, reduce memory usage, and provide more efficient data access, especially for large datasets.

1. Single Source of Truth

   - Previously: Data existed in both image cache and volume cache, leading to synchronization issues.
   - Now: Only one source of truth - the image cache.
   - Benefits: Improved syncing between stack and volume segmentations.

2. New Volume Creation Approach

   - Everything now loads as images.
   - Volume streaming is performed image by image.
   - Only images are cached in the image cache.
   - For volume rendering, data goes directly from image cache to GPU, bypassing CPU scalar data.
   - Benefits: Eliminated need for scalar data in CPU, reduced memory usage, improved performance.

3. VoxelManager for Tools

   - Acts as an intermediary between indexes and scalar data.
   - Provides mappers from IJK to indexes.
   - Retrieves information without creating scalar data.
   - Processes each image individually.
   - Benefits: Efficient handling of tools requiring pixel data in CPU.

4. Handling Non-Image Volumes

   - Volumes without images (e.g., NIFTI) are chopped and converted to stack format.
   - Makes non-image volumes compatible with the new image-based approach.

5. Optimized Caching Mechanism

   - Data stored in native format instead of always caching as float32.
   - On-the-fly conversion to required format when updating GPU textures.
   - Benefits: Reduced memory usage, eliminated unnecessary data type conversions.

6. Elimination of SharedArrayBuffer
   - Removed dependency on SharedArrayBuffer.
   - Each decoded image goes directly to the GPU 3D texture at the correct size and position.
   - Benefits: Reduced security constraints, simplified web worker implementation.

**Results**

- Streamlined data flow from image cache directly to GPU.
- Improved memory usage and performance.
- Enhanced compatibility with various volume formats.
- Optimized overall system architecture for image and volume handling.
- Simplified web worker implementation (ArrayBuffer is now sufficient).

### Introduction of VoxelManager

A new `VoxelManager` class has been introduced to handle voxel data more efficiently. This change eliminates the need for allocating large scalar data arrays for volumes, instead relying on individual images and an adapter called VoxelManager.

**Migration Steps:**

1. Replace direct scalar data access with `VoxelManager` methods:

   Instead of accessing `volume.getScalarData()`, use `volume.voxelManager` to interact with the data.

2. Scalar Data length:

   Use `voxelManager.getScalarDataLength()` instead of `scalarData.length`.

3. Scalar Data Manipulation:

   a. Use `getAtIndex(index)` and `setAtIndex(index, value)` for accessing and modifying voxel data.

   b. For 3D coordinates, use `getAtIJK(i, j, k)` and `setAtIJK(i, j, k, value)`.

4. Available VoxelManager Methods:

   - `getScalarData()`: Returns the entire scalar data array (only for IImage, not for volumes).
   - `getScalarDataLength()`: Returns the total number of voxels.
   - `getAtIndex(index)`: Gets the value at a specific index.
   - `setAtIndex(index, value)`: Sets the value at a specific index.
   - `getAtIJK(i, j, k)`: Gets the value at specific IJK coordinates.
   - `setAtIJK(i, j, k, value)`: Sets the value at specific IJK coordinates.
   - `getArrayOfModifiedSlices()`: Returns an array of modified slice indices.
   - `forEach(callback, options)`: Iterates over voxels with a callback function.
   - `getConstructor()`: Returns the constructor for the scalar data type.
   - `getBoundsIJK()`: Returns the bounds of the volume in IJK coordinates.
   - `toIndex(ijk)`: Converts IJK coordinates to a linear index.
   - `toIJK(index)`: Converts a linear index to IJK coordinates.

5. Handling modified slices:

   Use `voxelManager.getArrayOfModifiedSlices()` to get the list of modified slices.

6. Iterating over voxels:

   Use the `forEach` method for efficient iteration:

   ```javascript
   voxelManager.forEach(
     ({ value, index, pointIJK, pointLPS }) => {
       // Manipulate or process voxel data
     },
     {
       boundsIJK: optionalBounds,
       imageData: optionalImageData, // for LPS calculations
     }
   );
   ```

7. Getting volume information:

   - Dimensions: `volume.dimensions`
   - Spacing: `volume.spacing`
   - Direction: `volume.direction`
   - Origin: `volume.origin`

8. For RGB data:

   If dealing with RGB data, the `getAtIndex` and `getAtIJK` methods will return an array `[r, g, b]`.

9. Performance considerations:

   - Use `getAtIndex` and `setAtIndex` for bulk operations when possible, as they're generally faster than `getAtIJK` and `setAtIJK`.
   - When iterating over a large portion of the volume, consider using `forEach` for optimized performance.

10. Dynamic Volumes:

    For 4D datasets, additional methods are available:

    - `setTimePoint(timePoint)`: Sets the current time point.
    - `getAtIndexAndTimePoint(index, timePoint)`: Gets a value for a specific index and time point.

Example of migrating a simple volume processing function:

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```javascript
function processVolume(volume) {
  const scalarData = volume.getScalarData();
  for (let i = 0; i < scalarData.length; i++) {
    if (scalarData[i] > 100) {
      scalarData[i] = 100;
    }
  }
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```javascript
function processVolume(volume) {
  const voxelManager = volume.voxelManager;
  const length = voxelManager.getScalarDataLength();
  for (let i = 0; i < length; i++) {
    const value = voxelManager.getAtIndex(i);
    if (value > 100) {
      voxelManager.setAtIndex(i, 100);
    }
  }
}
```

  </TabItem>
</Tabs>

By following these expanded migration steps and utilizing the full capabilities of the VoxelManager, you can efficiently work with volume data while benefiting from the improved performance and reduced memory usage of the new system.

**Migration Steps For Volumes (IImageVolume):**

1. When processing volume data, search your custom codebase for `getScalarData` or `scalarData`. Instead, use `voxelManager` to access the scalar data API.

:::info
If you can't use the atomic data API through `getAtIndex` and `getAtIJK`, you can fall back to `voxelManager.getCompleteScalarDataArray()` to rebuild the full scalar data array like cornerstone3D 1.0. However, this is not recommended due to performance and memory concerns. Use it only as a last resort.

Also you can do `.setCompleteScalarDataArray` as well.
:::

**Migration Steps For Stack Images (IImage):**

1. there is not much changed here for stack images, you can still use `image.getPixelData()` OR access the scalarData array from the `voxelManager` with `image.voxelManager.getScalarData()`.

:::info
ONLY For volumes, there is no direct `scalarData` array. Instead, use `voxelManager` to access the scalar data at index or ijk. Manipulation of scalar data for single images remains unchanged.
:::

### Image Volume Construction

The construction of image volumes has been updated to use `VoxelManager` and new properties, eliminating the need for large scalar data arrays.

:::info
As mentioned, there is no scalarData array in the volume object, and imageIds is sufficient to describe the volume.
:::

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const streamingImageVolume = new StreamingImageVolume({
  volumeId,
  metadata,
  dimensions,
  spacing,
  origin,
  direction,
  scalarData,
  sizeInBytes,
  imageIds,
});
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
const streamingImageVolume = new StreamingImageVolume({
  volumeId,
  metadata,
  dimensions,
  spacing,
  origin,
  direction,
  imageIds,
  dataType,
  numberOfComponents,
});
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Remove `scalarData` and `sizeInBytes` from the constructor parameters.
2. Add `dataType` and `numberOfComponents` to the constructor parameters.
3. The `VoxelManager` will be created internally based on these parameters.

**Explanation:**
This change reflects the shift from using large scalar data arrays to using the VoxelManager for data management. It allows for more efficient memory usage and better handling of streaming data.

#### Accessing Volume Properties

Some volume properties are now accessed differently due to the `VoxelManager` integration. The reason is we don't create the vtkScalarData fully for volume so you can't access it like before.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const numberOfComponents = imageData
  .getPointData()
  .getScalars()
  .getNumberOfComponents();
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
const { numberOfComponents } = imageData.get('numberOfComponents');
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `getPointData().getScalars().getNumberOfComponents()` with `get('numberOfComponents')`.
2. Use the destructuring syntax to extract the `numberOfComponents` property.

::info
These changes represent a significant update to the Cornerstone library's handling of image volumes and textures. The introduction of the VoxelManager and the elimination of large scalar data arrays for volumes provide several benefits:

1. Reduced memory usage: By relying on individual images instead of a large array buffer, memory usage is significantly reduced, especially for large datasets.
2. Improved performance: The VoxelManager allows for more efficient data access and manipulation, leading to better overall performance.
3. Better streaming support: The new approach is better suited for streaming large datasets, as it doesn't require loading the entire volume into memory at once.
4. More flexible data management: The VoxelManager provides a unified interface for accessing and modifying voxel data, regardless of the underlying data structure.

Developers will need to update their code to use the new VoxelManager API and adjust how they interact with volume data and textures. While these changes may require significant updates to existing code, they provide a more efficient and flexible foundation for working with large medical imaging datasets.
:::

We have applied this new design to both volume and stack viewports.

## Image Loader

## VolumeLoader

The volume loading and caching functionality has undergone significant changes in version 2. The main updates include simplification of the API, removal of certain utility functions, and changes in the way volumes are created and cached.

### Changes in Volume Creation Functions

The `createLocalVolume` function has been updated to take `volumeId` as the first parameter and options as the second parameter.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function createLocalVolume(
  options: LocalVolumeOptions,
  volumeId: string,
  preventCache = false
): IImageVolume {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function createLocalVolume(
  volumeId: string,
  options = {} as LocalVolumeOptions
): IImageVolume {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update all calls to `createLocalVolume` by moving the `volumeId` parameter to the first position.
2. Remove the `preventCache` parameter and handle caching separately if needed.

### Changes in Derived Volume Creation

The `createAndCacheDerivedVolume` function now returns synchronously instead of returning a Promise.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
async function createAndCacheDerivedVolume(
  referencedVolumeId: string,
  options: DerivedVolumeOptions
): Promise<IImageVolume> {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function createAndCacheDerivedVolume(
  referencedVolumeId: string,
  options: DerivedVolumeOptions
): IImageVolume {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Remove `await` keywords when calling `createAndCacheDerivedVolume`.
2. Update any code that expects a Promise to handle the synchronous return value.

### Renamed Functions

Some functions have been renamed for clarity:

- `createAndCacheDerivedSegmentationVolume` is now `createAndCacheDerivedLabelmapVolume`
- `createLocalSegmentationVolume` is now `createLocalLabelmapVolume`

**Migration Steps:**

1. Update all calls to these functions with their new names.
2. Ensure that any code referencing these functions is updated accordingly.

### Target Buffer Type Migration

The `targetBufferType` option has been replaced with a `targetBuffer` object throughout the library. This change affects multiple functions and interfaces.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
interface DerivedImageOptions {
  targetBufferType?: PixelDataTypedArrayString;
  // ...
}

function createAndCacheDerivedImage(
  referencedImageId: string,
  options: DerivedImageOptions = {
    targetBufferType: 'Uint8Array',
  }
): Promise<IImage> {
  // ...
}

function createAndCacheDerivedImages(
  referencedImageIds: Array<string>,
  options: DerivedImageOptions & {
    targetBufferType?: PixelDataTypedArrayString;
  } = {}
): DerivedImages {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
interface DerivedImageOptions {
  targetBuffer?: {
    type: PixelDataTypedArrayString;
  };
  // ...
}

function createAndCacheDerivedImage(
  referencedImageId: string,
  options: DerivedImageOptions = {}
): IImage {
  // ...
}

function createAndCacheDerivedImages(
  referencedImageIds: string[],
  options: DerivedImageOptions & {
    targetBuffer?: {
      type: PixelDataTypedArrayString;
    };
  } = {}
): IImage[] {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update all interfaces and function signatures that use `targetBufferType` to use `targetBuffer` instead.
2. Change all occurrences of `targetBufferType: 'SomeType'` to `targetBuffer: { type: 'SomeType' }`.
3. Update all function calls that previously used `targetBufferType` to use the new `targetBuffer` object structure.
4. Review and update any code that relies on the `targetBufferType` property, ensuring it now uses `targetBuffer.type`.

### Changes in `createAndCacheDerivedImage` Function

The `createAndCacheDerivedImage` function now returns an `IImage` object directly instead of a Promise.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
export function createAndCacheDerivedImage(
  referencedImageId: string,
  options: DerivedImageOptions = {},
  preventCache = false
): Promise<IImage> {
  // ...
  return imageLoadObject.promise;
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
export function createAndCacheDerivedImage(
  referencedImageId: string,
  options: DerivedImageOptions = {}
): IImage {
  // ...
  return localImage;
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update any code that expects a Promise from `createAndCacheDerivedImage` to work with the directly returned `IImage` object.
2. Remove the `preventCache` parameter from function calls, as it's no longer used.

### Derived Image Creation

The `createAndCacheDerivedImage` function has been updated to return an `IImage` object directly instead of a Promise.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function createAndCacheDerivedImage(
  referencedImageId: string,
  options: DerivedImageOptions = {}
): Promise<IImage> {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function createAndCacheDerivedImage(
  referencedImageId: string,
  options: DerivedImageOptions = {}
): IImage {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Remove any `await` or `.then()` calls when using `createAndCacheDerivedImage`.
2. Update error handling to catch synchronous errors instead of Promise rejections.

### Image Loading Options

The `targetBufferType` option has been replaced with a `targetBuffer` object.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const options: DerivedImageOptions = {
  targetBufferType: 'Uint8Array',
};
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
const options: DerivedImageOptions = {
  targetBuffer: { type: 'Uint8Array' },
};
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `targetBufferType` with `targetBuffer` in all option objects.
2. Update the value to be an object with a `type` property.

### Segmentation Image Helpers

The segmentation image helper functions have been renamed and updated.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function createAndCacheDerivedSegmentationImages(
  referencedImageIds: Array<string>,
  options: DerivedImageOptions = {
    targetBufferType: 'Uint8Array',
  }
): DerivedImages {
  // ...
}

function createAndCacheDerivedSegmentationImage(
  referencedImageId: string,
  options: DerivedImageOptions = {
    targetBufferType: 'Uint8Array',
  }
): Promise<IImage> {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function createAndCacheDerivedLabelmapImages(
  referencedImageIds: string[],
  options = {} as DerivedImageOptions
): IImage[] {
  return createAndCacheDerivedImages(referencedImageIds, {
    ...options,
    targetBuffer: { type: 'Uint8Array' },
  });
}

function createAndCacheDerivedLabelmapImage(
  referencedImageId: string,
  options = {} as DerivedImageOptions
): IImage {
  return createAndCacheDerivedImage(referencedImageId, {
    ...options,
    targetBuffer: { type: 'Uint8Array' },
  });
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Rename `createAndCacheDerivedSegmentationImages` to `createAndCacheDerivedLabelmapImages`.
2. Rename `createAndCacheDerivedSegmentationImage` to `createAndCacheDerivedLabelmapImage`.
3. Update function calls to use the new names and parameter structure.
4. Remove any `await` or `.then()` calls when using `createAndCacheDerivedLabelmapImage`.

## Cache Class

The `Cache` class has undergone significant changes in version 2. Here are the main updates and breaking changes:

### Removal of Volume-specific Cache Size

The separate volume cache size has been removed, simplifying the cache management, since we only rely on the image cache solely.

**Migration Steps**:

1. Remove any references to `_volumeCacheSize` if you had

### isCacheable Method Update

The `isCacheable` method has been updated to consider shared cache keys. Which means since we have moved to the image cache only, we need to be careful
on which images can be decached so we don't remove the volume that is still referenced by the view.

### New putImageSync and putVolumeSync Methods

A new `putImageSync` method has been added to directly put an image into the cache synchronously.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
// Method did not exist
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
public putImageSync(imageId: string, image: IImage): void {
  // ... (validation code)
```

public putVolumeSync(volumeId: string, volume: IImageVolume): void {
// ... (validation code)
}

  </TabItem>
</Tabs>

**Migration Steps**:

1. Use the new `putImageSync` and `putVolumeSync` methods when you need to add an image or volume to the cache synchronously.

## Renaming and Nomenclature

### Enums

#### Removal of SharedArrayBufferModes

As we no longer use SharedArrayBuffer, this Enum has been removed.

The following methods have also been removed from @cornerstonejs/core:

- getShouldUseSharedArrayBuffer
- setUseSharedArrayBuffer
- resetUseSharedArrayBuffer

#### ViewportType.WholeSlide -> ViewportType.WHOLE_SLIDE

to match the rest of the library

before

```js
const viewportInput = {
    viewportId,
    type: ViewportType.WholeSlide,
    element,
    defaultOptions: {
      background: <Types.Point3>[0.2, 0, 0.2],
    },
  };

  renderingEngine.enableElement(viewportInput);

```

after

```js
const viewportInput = {
    viewportId,
    type: ViewportType.WHOLE_SLIDE,
    element,
    defaultOptions: {
      background: <Types.Point3>[0.2, 0, 0.2],
    },
  };

  renderingEngine.enableElement(viewportInput);

```

### Events and Event Details

#### VOLUME_SCROLL_OUT_OF_BOUNDS -> VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS

is now `VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS`

#### STACK_VIEWPORT_NEW_STACK -> VIEWPORT_NEW_IMAGE_SET

is now VIEWPORT_NEW_IMAGE_SET adn we will gradually bring all viewports to use this event instead

in addition the event is now occurring on the element not the eventTarget

```js
eventTarget.addEventListener(Events.VIEWPORT_NEW_IMAGE_SET, newStackHandler);

// should be now

element.addEventListener(Events.VIEWPORT_NEW_IMAGE_SET, newStackHandler);
```

<details>
<summary>Why?</summary>

We made this change to maintain consistency, as all other events like VOLUME_NEW_IMAGE were occurring on the element. This modification makes more sense because when the viewport has a new stack, it should trigger an event on the viewport element itself.

</details>

#### CameraModifiedEventDetail

Does not publish the `rotation` anymore, and it has moved to ICamera which is published in the event

```js
type CameraModifiedEventDetail = {
  previousCamera: ICamera,
  camera: ICamera,
  element: HTMLDivElement,
  viewportId: string,
  renderingEngineId: string,
};
```

access the rotation from the camera object which previously was in the event detail root.

#### ImageVolumeModifiedEventDetail

The `imageVolume` is no longer available in the event detail. Instead, only the `volumeId` is displayed in the event details to maintain consistency with other library entries. This change ensures a uniform approach across all library content.

If you need the imageVolume you can get it from the `cache.getVolume` method

---

# 4D Or Dynamic Volume

We think this is important enough to have a section for itself

## imageIdsGroups is now imageIdGroups

if you were using splitImageIdsBy4DTags to get the imageIdsGroups now you should expect the return
object to have ImageIdGroups instead of ImageIdsGroups

migration

```js
const { imageIdsGroups } = splitImageIdsBy4DTags(imageIds);
```

should be

```js
const { imageIdGroups } = splitImageIdsBy4DTags(imageIds);
```

## StreamingDynamicImageVolume

### Constructor Changes

The constructor signature has been updated to include `imageIdGroups` instead of separate `scalarData` arrays.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
constructor(
  imageVolumeProperties: Types.ImageVolumeProps & { splittingTag: string },
  streamingProperties: Types.IStreamingVolumeProperties
) {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
constructor(
  imageVolumeProperties: ImageVolumeProps & {
    splittingTag: string;
    imageIdGroups: string[][];
  },
  streamingProperties: IStreamingVolumeProperties
) {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update the constructor call to include `imageIdGroups` instead of `scalarData`.
2. Remove any code that previously handled `scalarData` arrays.

### New Methods for ImageId Management

Version 2 introduces new methods for managing image IDs:

- `getCurrentTimePointImageIds()`
- `flatImageIdIndexToTimePointIndex()`
- `flatImageIdIndexToImageIdIndex()`

**Migration Steps:**

1. Use `getCurrentTimePointImageIds()` to get image IDs for the current time point.
2. Utilize `flatImageIdIndexToTimePointIndex()` and `flatImageIdIndexToImageIdIndex()` for converting between flat indices and time point/image indices.

### Removal of getScalarData Method and Using VoxelManager for Dynamic Image Volumes

The `getScalarData()` method has been removed in version 2 in favor of the new voxel Manager

In version 2, the `StreamingDynamicImageVolume` class now uses a `VoxelManager` to handle time point data. This change provides more efficient memory management and easier access to voxel data across different time points. Here's how you can use the `VoxelManager` to access and manipulate data in your dynamic image volumes:

#### Accessing Voxel Data

To access voxel data for the current time point:

```typescript
const voxelValue = volume.voxelManager.get(index);
```

To access voxel data for a specific time point:

```typescript
const voxelValue = volume.voxelManager.getAtIndexAndTimePoint(index, timePoint);
```

#### Getting Scalar Data

To get the complete scalar data array for the current time point:

```typescript
const scalarData = volume.voxelManager.getCurrentTimePointScalarData();
```

To get the scalar data for a specific time point:

```typescript
const scalarData = volume.voxelManager.getTimePointScalarData(timePoint);
```

#### Getting Volume Information

You can access various volume properties through the `VoxelManager`:

```typescript
const scalarDataLength = volume.voxelManager.getScalarDataLength();
const dataType = volume.voxelManager.getConstructor();
const dataRange = volume.voxelManager.getRange();
const middleSliceData = volume.voxelManager.getMiddleSliceData();
```

**Migration Steps:**

1. Replace direct access to `scalarData` arrays with calls to the appropriate `VoxelManager` methods.
2. Update any code that manually managed time points to use the `VoxelManager`'s time point-aware methods.
3. Use `getCurrentTimePointScalarData()` or `getTimePointScalarData(tp)` instead of the removed `getScalarData()` method.
4. If you need to perform operations across all time points, you can iterate through them using the `numTimePoints` property and the `getTimePointScalarData(tp)` method.

By leveraging the `VoxelManager`, you can efficiently work with dynamic image volumes without manually managing multiple scalar data arrays. This approach provides better performance and memory usage, especially for large datasets with many time points.

## Exports Imports

If you were previously using `@cornerstonejs/streaming-image-volume-loader`, you'll need to update your imports and potentially adjust your code to use the new integrated volume loading API in `@cornerstonejs/core`.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
import {
  cornerstoneStreamingDynamicImageVolumeLoader,
  StreamingDynamicImageVolume,
  helpers,
  Enums,
} from '@cornerstonejs/streaming-image-volume-loader';

Enums.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED;
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
import {
  cornerstoneStreamingDynamicImageVolumeLoader,
  StreamingDynamicImageVolume,
} from '@cornerstonejs/core';

import { getDynamicVolumeInfo } from '@cornerstonejs/core/utilities';
import { Enums } from '@cornerstonejs/core/enums';

Enums.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED;
```

  </TabItem>
</Tabs>

## getDataInTime

The imageCoordinate option is now worldCoordinate, to better reflect that it's a world coordinate and not an image coordinate.

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getDataInTime(
  dynamicVolume: Types.IDynamicImageVolume,
  options: {
    frameNumbers?;
    maskVolumeId?;
    imageCoordinate?;
  }
): number[] | number[][];
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```typescript
function getDataInTime(
  dynamicVolume: Types.IDynamicImageVolume,
  options: {
    frameNumbers?;
    maskVolumeId?;
    worldCoordinate?;
  }
): number[] | number[][];
```

</TabItem>
</Tabs>

### Usage Example

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const result = getDataInTime(dynamicVolume, {
  frameNumbers: [0, 1, 2],
  imageCoordinate: [100, 100, 100],
});
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```typescript
const result = getDataInTime(dynamicVolume, {
  frameNumbers: [0, 1, 2],
  worldCoordinate: [100, 100, 100],
});
```

</TabItem>
</Tabs>

## generateImageFromTimeData

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function generateImageFromTimeData(
  dynamicVolume: Types.IDynamicImageVolume,
  operation: string,
  frameNumbers?: number[]
);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```typescript
function generateImageFromTimeData(
  dynamicVolume: Types.IDynamicImageVolume,
  operation: Enums.GenerateImageType,
  options: {
    frameNumbers?: number[];
  }
): Float32Array;
```

</TabItem>
</Tabs>

### Key Changes

1. `operation` now uses `Enums.GenerateImageType` enum.
2. Frame numbers are passed in an options object.
3. Function explicitly returns `Float32Array`.

### Usage Example

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const result = generateImageFromTimeData(dynamicVolume, 'SUM', [0, 1, 2]);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```typescript
const result = generateImageFromTimeData(
  dynamicVolume,
  Enums.GenerateImageType.SUM,
  {
    frameNumbers: [0, 1, 2],
  }
);
```

</TabItem>
</Tabs>

## Summary of Other Changes

- New `updateVolumeFromTimeData` function added for in-place volume updates.
- Both functions now use `voxelManager` for improved performance.
- Enhanced error handling and standardized error messages.
- Operations now use `Enums.GenerateImageType` for better type safety.

# @cornerstonejs/tools

## triggerAnnotationRenderForViewportIds

Now only requires viewportIds and doesn't need renderingEngine anymore

```js
triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds) ---> triggerAnnotationRenderForViewportIds(viewportIds)
```

<details>
<summary>Why?</summary>
Since there is one rendering engine per viewport, there is no need to pass the rendering engine as an argument.
</details>

## Tools

### StackScrollMouseWheelTool -> StackScrollTool

We've decoupled the Mouse Wheel from the tool itself, allowing it to be applied as a binding similar to other mouse bindings.

This change offers several advantages:

- It can be combined with other mouse bindings
- It can be paired with keyboard bindings

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
cornerstoneTools.addTool(StackScrollMouseWheelTool);
toolGroup.addTool(StackScrollMouseWheelTool.toolName);
toolGroup.setToolActive(StackScrollMouseWheelTool.toolName);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
cornerstoneTools.addTool(StackScrollTool);
toolGroup.addTool(StackScrollTool.toolName);
toolGroup.setToolActive(StackScrollTool.toolName, {
  bindings: [
    {
      mouseButton: MouseBindings.Wheel,
    },
  ],
});
```

  </TabItem>
</Tabs>

### BaseTool

The `getTargetVolumeId` method has been removed in favor of `getTargetId`, and `getTargetIdImage` has been renamed to `getTargetImageData` to make it more clear that it is an image data.

### Usage Example

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const volumeId = this.getTargetVolumeId(viewport);
const imageData = this.getTargetIdImage(targetId, renderingEngine);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```typescript
const imageData = this.getTargetImageData(targetId);
```

</TabItem>
</Tabs>

## New Segmentation Model

We have a new segmentation model that is more flexible and easier to use.

### Same Terminology, Different Architecture

In Cornerstone3D version 2, we've made significant architectural changes to our segmentation model while maintaining familiar terminology. This redesign aims to provide a more flexible and intuitive approach to working with segmentations across different viewports. Here are the key changes and the reasons behind them:

1. **Viewport-Specific, Not Tool Group-Based**:

   - Old: Segmentations were tied to tool groups, which typically consist of multiple viewports. This created complications when users wanted to add segmentations to some viewports but not others within the same tool group.
   - New: Segmentations are now viewport-specific. Instead of adding or removing representations to a tool group, users can add them directly to viewports. This provides much finer control over what each viewport renders.
   - Why: We discovered that tying rendering to a tool group is not an effective approach. It often necessitated creating an extra tool group for a specific viewport to customize or prevent rendering.

2. **Simplified Identification of Segmentation Representations**:

   - Old: Required a unique segmentationRepresentationUID for identification.
   - New: Segmentation representations are identified by a combination of `segmentationId` and representation `type`. This allows each viewport to have different representations of the same segmentation.
   - Why: This simplification makes it easier to manage and reference segmentation representations across different viewports.

3. **Decoupling of Data and Visualization**:

   - Old: Segmentation rendering was tightly coupled with tool groups.
   - New: Segmentation is now treated purely as data, separate from the tools used to interact with it.
   - Why: While it's appropriate for tools to be bound to tool groups, viewport-specific functionalities like segmentation rendering should be the responsibility of individual viewports. This separation allows for more flexible rendering and interaction options across different viewports.

4. **Polymorphic Segmentation Support**:

   - The new architecture better supports the concept of polymorphic segmentations, where a single segmentation can have multiple representations (e.g., labelmap, contour, surface) that can be efficiently converted between each other.
   - Why: This flexibility allows for more efficient storage, analysis, and real-time visualization of segmentations.

5. **Consistent API Across Representation Types**:
   - The new API provides a unified way to work with different segmentation representations, making it easier to manage complex scenarios involving multiple viewports and representation types.
   - Why: This consistency simplifies development and reduces the likelihood of errors when working with different segmentation types.

These architectural changes provide a more robust foundation for working with segmentations, especially in complex multi-viewport scenarios. The new approach has proven to be highly effective and opens up possibilities for future enhancements. While the core concepts remain similar, the way you interact with segmentations in your code will change significantly. This migration guide will walk you through these changes, providing before-and-after examples to help you update your existing codebase to the new architecture.

### Segmentation State

The `Segmentation` type has been restructured to better organize segment information and representation data. Let's take a look at the changes before we
talk about migration guides.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
type Segmentation = {
  segmentationId: string;
  type: Enums.SegmentationRepresentations;
  label: string;
  activeSegmentIndex: number;
  segmentsLocked: Set<number>;
  cachedStats: { [key: string]: number };
  segmentLabels: { [key: string]: string };
  representationData: SegmentationRepresentationData;
};
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
type Segmentation = {
  segmentationId: string;
  label: string;
  segments: {
    [segmentIndex: number]: Segment;
  };
  representationData: RepresentationsData;
};

type Segment = {
  segmentIndex: number;
  label: string;
  locked: boolean;
  cachedStats: { [key: string]: unknown };
  active: boolean;
};
```

  </TabItem>
</Tabs>

The new segmentation state model offers a more organized data structure. Previously scattered information such as `cachedStats`, `segmentLabels`, and `activeSegmentIndex` has been consolidated under the `segments` property. This restructuring enhances clarity and efficiency. In the following sections, we'll discuss migration guides that will explain how to access and modify these properties within the new structure. This reorganization primarily affects the segmentation store level.

#### Representation Data Key

The `SegmentationRepresentations` enum has been updated to use title case instead of uppercase to make it match the rest of the Enums.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
enum SegmentationRepresentations {
  Labelmap = 'LABELMAP',
  Contour = 'CONTOUR',
  Surface = 'SURFACE',
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
enum SegmentationRepresentations {
  Labelmap = 'Labelmap',
  Contour = 'Contour',
  Surface = 'Surface',
}
```

  </TabItem>
</Tabs>

This change affects how representation data is accessed:

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const representationData = segmentation.representationData.SURFACE;
const representationData = segmentation.representationData.LABELMAP;
const representationData = segmentation.representationData.CONTOUR;
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
const representationData = segmentation.representationData.Surface;
const representationData = segmentation.representationData.Labelmap;
const representationData = segmentation.representationData.Contour;
```

  </TabItem>
</Tabs>

#### Segmentation Representation

The representation structure has been simplified and is now viewport-specific.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
type ToolGroupSpecificRepresentation =
  | ToolGroupSpecificLabelmapRepresentation
  | ToolGroupSpecificContourRepresentation;

type ToolGroupSpecificRepresentationState = {
  segmentationRepresentationUID: string;
  segmentationId: string;
  type: Enums.SegmentationRepresentations;
  active: boolean;
  segmentsHidden: Set<number>;
  colorLUTIndex: number;
};

type SegmentationState = {
  toolGroups: {
    [key: string]: {
      segmentationRepresentations: ToolGroupSpecificRepresentations;
      config: SegmentationRepresentationConfig;
    };
  };
};
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
type SegmentationRepresentation =
  | LabelmapRepresentation
  | ContourRepresentation
  | SurfaceRepresentation;

type BaseSegmentationRepresentation = {
  colorLUTIndex: number;
  segmentationId: string;
  type: Enums.SegmentationRepresentations;
  visible: boolean;
  active: boolean;
  segments: {
    [segmentIndex: number]: {
      visible: boolean;
    };
  };
};

type SegmentationState = {
  viewportSegRepresentations: {
    [viewportId: string]: Array<SegmentationRepresentation>;
  };
};
```

  </TabItem>
</Tabs>

Previously, the segmentation representation was tool group specific, which led to some issues. In the new structure, segmentation representation is viewport specific. It now consists of a segmentationId, a type, and various settings for that segmentation. As a result of this change, several functions have been removed or modified. Here's a summary of the changes:

#### Removed Functions

- `getDefaultSegmentationStateManager`
- `getSegmentationRepresentations`
- `getAllSegmentationRepresentations`
- `getSegmentationIdRepresentations`
- `findSegmentationRepresentationByUID`
- `getToolGroupIdsWithSegmentation`
- `getToolGroupSpecificConfig`
- `setToolGroupSpecificConfig`
- `getGlobalConfig`
- `setGlobalConfig`
- `setSegmentationRepresentationSpecificConfig`
- `getSegmentationRepresentationSpecificConfig`
- `getSegmentSpecificRepresentationConfig`
- `setSegmentSpecificRepresentationConfig`
- `getToolGroupIdFromSegmentationRepresentationUID`
- `addSegmentationRepresentation`
- `getSegmentationRepresentationByUID`

#### New Functions

- `addSegmentations(segmentationInputArray)`
- `removeSegmentation(segmentationId)`
- `getSegmentation(segmentationId)`
- `getSegmentations()`
- `getSegmentationRepresentation(viewportId, specifier)`
- `getSegmentationRepresentations(viewportId, specifier)`
- `removeSegmentationRepresentation(viewportId, specifier, immediate)`
- `removeAllSegmentationRepresentations()`
- `removeLabelmapRepresentation(viewportId, segmentationId, immediate)`
- `removeContourRepresentation(viewportId, segmentationId, immediate)`
- `removeSurfaceRepresentation(viewportId, segmentationId, immediate)`
- `getViewportSegmentations(viewportId, type)`
- `getViewportIdsWithSegmentation(segmentationId)`
- `getCurrentLabelmapImageIdForViewport(viewportId, segmentationId)`
- `updateLabelmapSegmentationImageReferences(segmentationId, imageIds)`
- `getStackSegmentationImageIdsForViewport(viewportId, segmentationId)`
- `destroy()`

### Removal of SegmentationDisplayTool

There's no need to add the SegmentationDisplayTool to the toolGroup anymore.

Before

```js
toolGroup2.addTool(SegmentationDisplayTool.toolName);

toolGroup1.setToolEnabled(SegmentationDisplayTool.toolName);
```

Now

```js
// nothing
```

### Stack Labelmaps

To create a Stack Labelmap, you no longer need to manually create a reference between labelmap imageIds and viewport imageIds. We now handle this process automatically for you.

This is a long Why ...

The previous model required users to provide an imageIdReferenceMap, which linked labelmap imageIds to viewport imageIds. This approach presented several challenges when implementing advanced segmentation use cases:

1. Manual creation of the map was error-prone, particularly regarding the order of imageIds.

2. Once a segmentation was associated with specific viewport imageIds, rendering it elsewhere became problematic. For example:

   - Rendering a CT image stack segmentation on a single key image.
   - Rendering a CT image stack segmentation on a stack that includes both CT and other images.
   - Rendering a DX dual energy segmentation from energy 1 on energy 2.
   - Rendering a CT labelmap from a stack viewport on a PT labelmap in the same space.

These scenarios highlight the limitations of the previous model.

We've now transitioned to a system where users only need to provide imageIds. During rendering, we match the viewport's current imageId against the labelmap imageIds and render the segmentation if there's a match. This matching process occurs in the SegmentationStateManager, with the criterion being that the segmentation must be in the same plane as the referenced viewport.

This new approach enables numerous additional use cases and offers greater flexibility in segmentation rendering.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
segmentation.addSegmentations([
  {
    segmentationId,
    representation: {
      type: csToolsEnums.SegmentationRepresentations.Labelmap,
      data: {
        imageIdReferenceMap:
          cornerstoneTools.utilities.segmentation.createImageIdReferenceMap(
            imageIds,
            segmentationImageIds
          ),
      },
    },
  },
]);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
segmentation.addSegmentations([
  {
    segmentationId,
    representation: {
      type: csToolsEnums.SegmentationRepresentations.Labelmap,
      data: {
        imageIds: segmentationImageIds,
      },
    },
  },
]);
```

  </TabItem>
</Tabs>

### Adding Segmentations

#### Function Signature Update

The `addSegmentations` function now accepts an optional `suppressEvents` parameter.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function addSegmentations(
  segmentationInputArray: SegmentationPublicInput[]
): void;
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function addSegmentations(
  segmentationInputArray: SegmentationPublicInput[],
  suppressEvents?: boolean
): void;
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update any calls to `addSegmentations` to include the `suppressEvents` parameter if needed.
2. If you don't want to suppress events, you can omit the second parameter.

#### SegmentationPublicInput Type Updates

The `SegmentationPublicInput` type has been extended to include an optional `config` property.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
type SegmentationPublicInput = {
  segmentationId: string;
  representation: {
    type: Enums.SegmentationRepresentations;
    data?: RepresentationData;
  };
};
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
type SegmentationPublicInput = {
  segmentationId: string;
  representation: {
    type: Enums.SegmentationRepresentations;
    data?: RepresentationData;
  };
  config?: {
    segments?: {
      [segmentIndex: number]: Partial<Segment>;
    };
    label?: string;
  };
};
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update any code that creates or manipulates `SegmentationPublicInput` objects to include the new `config` property if needed.
2. Replace specific segmentation data types with the generic `RepresentationData` type.

### Adding Segmentation Representations

#### Viewport-Centric Approach

The API now focuses on viewports instead of tool groups, providing more granular control over segmentation representations.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function addSegmentationRepresentations(
  toolGroupId: string,
  representationInputArray: RepresentationPublicInput[],
  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig
): Promise<string[]>;
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function addSegmentationRepresentations(
  viewportId: string,
  segmentationInputArray: RepresentationPublicInput[]
);
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `toolGroupId` with `viewportId` in function calls.
2. Remove the `toolGroupSpecificRepresentationConfig` parameter.
3. Update any code that relies on the returned Promise of segmentation representation UIDs.

#### RepresentationPublicInput Changes

The `RepresentationPublicInput` type has been simplified and some properties have been renamed or removed.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
type RepresentationPublicInput = {
  segmentationId: string;
  type: Enums.SegmentationRepresentations;
  options?: {
    segmentationRepresentationUID?: string;
    colorLUTOrIndex?: Types.ColorLUT | number;
    polySeg?: {
      enabled: boolean;
      options?: any;
    };
  };
};
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
type RepresentationPublicInput = {
  segmentationId: string;
  type?: Enums.SegmentationRepresentations;
  config?: {
    colorLUTOrIndex?: Types.ColorLUT[] | number;
  };
};
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Remove the `options` property and move `colorLUTOrIndex` to the `config` object.
2. Remove `segmentationRepresentationUID` and `polySeg` properties if used, polySEG is default enabled.
3. Update the `colorLUTOrIndex` type to accept an array of `Types.ColorLUT` instead of a single value.

#### New Representation-Specific Functions

Version 2 introduces new functions for adding specific types of segmentation representations to viewports.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
// No equivalent functions in version 1
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function addContourRepresentationToViewport(
  viewportId: string,
  contourInputArray: RepresentationPublicInput[]
);

function addLabelmapRepresentationToViewport(
  viewportId: string,
  labelmapInputArray: RepresentationPublicInput[]
);

function addSurfaceRepresentationToViewport(
  viewportId: string,
  surfaceInputArray: RepresentationPublicInput[]
);
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace generic `addSegmentationRepresentations` calls with the appropriate representation-specific function.
2. Update the input array to match the new `RepresentationPublicInput` type.
3. Remove any type-specific logic from your code, as it's now handled by these new functions.

#### Multi-Viewport Functions

Version 2 introduces new functions for adding segmentation representations to multiple viewports simultaneously.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
// No equivalent functions in version 1
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function addContourRepresentationToViewportMap(viewportInputMap: {
  [viewportId: string]: RepresentationPublicInput[];
});

function addLabelmapRepresentationToViewportMap(viewportInputMap: {
  [viewportId: string]: RepresentationPublicInput[];
});

function addSurfaceRepresentationToViewportMap(viewportInputMap: {
  [viewportId: string]: RepresentationPublicInput[];
});
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. If you were previously adding representations to multiple tool groups, refactor your code to use these new multi-viewport functions.
2. Create a `viewportInputMap` object with viewport IDs as keys and arrays of `RepresentationPublicInput` as values.
3. Call the appropriate multi-viewport function based on the representation type.

### Events

Since we moved from toolGroup to viewport, many events have been renamed to include `viewportId` instead of `toolGroupId`, and
some event details have been changed to include `segmentationId` instead of `segmentationRepresentationUID` or toolGroupId

#### Removal of ToolGroup Specific Events

The `triggerSegmentationRepresentationModified` and `triggerSegmentationRepresentationRemoved` functions have been removed. Instead, the library now uses a more generalized approach for handling segmentation events.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function triggerSegmentationRepresentationModified(
  toolGroupId: string,
  segmentationRepresentationUID?: string
): void {
  // ...
}

function triggerSegmentationRepresentationRemoved(
  toolGroupId: string,
  segmentationRepresentationUID: string
): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function triggerSegmentationRepresentationModified(
  viewportId: string,
  segmentationId: string,
  type?: SegmentationRepresentations
): void {
  // ...
}

function triggerSegmentationRepresentationRemoved(
  viewportId: string,
  segmentationId: string,
  type: SegmentationRepresentations
): void {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `toolGroupId` with `viewportId` in function calls.
2. Replace `segmentationRepresentationUID` with `segmentationId`.
3. Add the `type` parameter to specify the segmentation representation type.

#### Simplified Segmentation Modified Event

The `triggerSegmentationModified` function has been simplified to always require a `segmentationId`.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function triggerSegmentationModified(segmentationId?: string): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function triggerSegmentationModified(segmentationId: string): void {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Ensure that `segmentationId` is always provided when calling `triggerSegmentationModified`.
2. Remove any logic that handles the case where `segmentationId` is undefined.

#### Updated Event Detail Types

Several event detail types have been updated to reflect the changes in the segmentation system:

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
type SegmentationRepresentationModifiedEventDetail = {
  toolGroupId: string;
  segmentationRepresentationUID: string;
};

type SegmentationRepresentationRemovedEventDetail = {
  toolGroupId: string;
  segmentationRepresentationUID: string;
};

type SegmentationRenderedEventDetail = {
  viewportId: string;
  toolGroupId: string;
};
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
type SegmentationRepresentationModifiedEventDetail = {
  segmentationId: string;
  type: string;
  viewportId: string;
};

type SegmentationRepresentationRemovedEventDetail = {
  segmentationId: string;
  type: string;
  viewportId: string;
};

type SegmentationRenderedEventDetail = {
  viewportId: string;
  segmentationId: string;
  type: string;
};
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update event listeners to use the new event detail types.
2. Replace `toolGroupId` with `viewportId` where applicable.
3. Use `segmentationId` instead of `segmentationRepresentationUID`.
4. Add handling for the new `type` field in event details.

### Segmentation Config/Style

In Cornerstone3D version 2.x, we have significantly refactored the segmentation configuration APIs to provide a more flexible and unified approach for managing segmentation styles across different representations (Labelmap, Contour, Surface). The old APIs for getting and setting segmentation configurations have been replaced with new functions that utilize a specifier object to target specific segmentations, viewports, and segments.

#### Removed Functions

- `getGlobalConfig`
- `setGlobalConfig`
- `getGlobalRepresentationConfig`
- `setGlobalRepresentationConfig`
- `getToolGroupSpecificConfig`
- `setToolGroupSpecificConfig`
- `getSegmentSpecificConfig`
- `setSegmentSpecificConfig`
- `getSegmentationRepresentationSpecificConfig`
- `setSegmentationRepresentationSpecificConfig`

#### New Functions

- `getStyle(specifier)`
- `setStyle(specifier, style)`
- `setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations)`
- `getRenderInactiveSegmentations(viewportId)`
- `resetToGlobalStyle()`
- `hasCustomStyle(specifier)`

#### Getting Global Segmentation Config

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦" default>

```js
// Get the global segmentation config
const globalConfig = getGlobalConfig();

// Get global representation config for a specific representation type
const labelmapConfig = getGlobalRepresentationConfig(
  SegmentationRepresentations.Labelmap
);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```js
// Get the global style for a specific representation type
const labelmapStyle = getStyle({ type: SegmentationRepresentations.Labelmap });
```

</TabItem>
</Tabs>

##### Setting Global Segmentation Config

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦" default>

```js
// Set the global segmentation config
setGlobalConfig(newGlobalConfig);

// Set global representation config for a specific representation type
setGlobalRepresentationConfig(
  SegmentationRepresentations.Labelmap,
  newLabelmapConfig
);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```js
// Set the global style for a specific representation type
setStyle({ type: SegmentationRepresentations.Labelmap }, newLabelmapStyle);
```

</TabItem>
</Tabs>

#### Getting and Setting ToolGroup-Specific Config

ToolGroup-specific configurations have been removed in favor of viewport-specific styles. The following will set the style for a specific viewport and specific segmentation.

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦" default>

```js
// Get toolGroup-specific config
const toolGroupConfig = getToolGroupSpecificConfig(toolGroupId);

// Set toolGroup-specific config
setToolGroupSpecificConfig(toolGroupId, newToolGroupConfig);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```js
// Set style for a specific viewport and segmentation representation
setStyle(
  {
    viewportId: 'viewport1',
    segmentationId: 'segmentation1',
    type: SegmentationRepresentations.Labelmap,
  },
  newLabelmapStyle
);

// Get style for a specific viewport and segmentation representation
const style = getStyle({
  viewportId: 'viewport1',
  segmentationId: 'segmentation1',
  type: SegmentationRepresentations.Labelmap,
});
```

</TabItem>
</Tabs>

#### Getting and Setting Segmentation Representation-Specific Config

In Cornerstone3D version 2.x, the functions for getting and setting segmentation representation-specific configurations have been replaced with a unified style management API. The old functions:

`getSegmentationRepresentationSpecificConfig`
`setSegmentationRepresentationSpecificConfig`

are no longer available. Instead, you should use the getStyle and setStyle functions with a specifier object to target specific segmentations and representations.

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```js
// Get segmentation representation-specific config
const representationConfig = getSegmentationRepresentationSpecificConfig(
  toolGroupId,
  segmentationRepresentationUID
);

// Set segmentation representation-specific config
setSegmentationRepresentationSpecificConfig(
  toolGroupId,
  segmentationRepresentationUID,
  {
    LABELMAP: {
      renderOutline: true,
      outlineWidth: 2,
    },
  }
);
```

</TabItem>
<TabItem value="After" label="After ðŸš€ðŸš€">

```js
// Get style for a specific segmentation representation
const style = getStyle({
  segmentationId: 'segmentation1',
  type: SegmentationRepresentations.Labelmap,
});

// Set style for a specific segmentation representation in all viewports
setStyle(
  {
    segmentationId: 'segmentation1',
    type: SegmentationRepresentations.Labelmap,
  },
  {
    renderOutline: true,
    outlineWidth: 2,
  }
);
```

</TabItem>
</Tabs>

#### Getting and Setting Segment-Specific Config

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```js
// Get segment-specific config
const segmentConfig = getSegmentSpecificConfig(
  toolGroupId,
  segmentationRepresentationUID,
  segmentIndex
);

// Set segment-specific config
setSegmentSpecificConfig(
  toolGroupId,
  segmentationRepresentationUID,
  segmentIndex,
  newSegmentConfig
);
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```js
// Set style for a specific segment
setStyle(
  {
    segmentationId: 'segmentation1',
    type: SegmentationRepresentations.Labelmap,
    segmentIndex: 1,
  },
  newSegmentStyle
);

// Get style for a specific segment
const segmentStyle = getStyle({
  segmentationId: 'segmentation1',
  type: SegmentationRepresentations.Labelmap,
  segmentIndex: 1,
});
```

</TabItem>
</Tabs>

#### Setting Render Inactive Segmentations

The function to enable or disable rendering of inactive segmentations has been updated.

**Before**

This was part of the segmentation configuration:

```js
setGlobalConfig({ renderInactiveSegmentations: true });
```

**After**

Use `setRenderInactiveSegmentations`:

```js
// Set whether to render inactive segmentations in a viewport
setRenderInactiveSegmentations(viewportId, true);

// Get whether inactive segmentations are rendered in a viewport
const renderInactive = getRenderInactiveSegmentations(viewportId);
```

#### Resetting to Global Style

To reset all segmentation styles to the global style:

```js
resetToGlobalStyle();
```

#### Example Migration

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
import {
  getGlobalConfig,
  getGlobalRepresentationConfig,
  getToolGroupSpecificConfig,
  setGlobalConfig,
  setGlobalRepresentationConfig,
  setToolGroupSpecificConfig,
  setSegmentSpecificConfig,
  getSegmentSpecificConfig,
  setSegmentationRepresentationSpecificConfig,
  getSegmentationRepresentationSpecificConfig,
} from './segmentationConfig';

// Get the global segmentation config
const globalConfig = getGlobalConfig();

// Set global representation config
setGlobalRepresentationConfig(SegmentationRepresentations.Labelmap, {
  renderOutline: true,
  outlineWidth: 2,
});

// Set toolGroup-specific config
setToolGroupSpecificConfig(toolGroupId, {
  representations: {
    LABELMAP: {
      renderOutline: false,
    },
  },
});

// Set segment-specific config
setSegmentSpecificConfig(
  toolGroupId,
  segmentationRepresentationUID,
  segmentIndex,
  {
    LABELMAP: {
      renderFill: false,
    },
  }
);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
import {
  getStyle,
  setStyle,
  setRenderInactiveSegmentations,
  getRenderInactiveSegmentations,
  resetToGlobalStyle,
  hasCustomStyle,
} from '@cornerstonejs/core';

// Get the global style for Labelmap representation
const labelmapStyle = getStyle({ type: SegmentationRepresentations.Labelmap });

// Set the global style for Labelmap representation
setStyle(
  { type: SegmentationRepresentations.Labelmap },
  {
    renderOutline: true,
    outlineWidth: 2,
  }
);

// Set style for a specific viewport and segmentation
setStyle(
  {
    viewportId: 'viewport1',
    segmentationId: 'segmentation1',
    type: SegmentationRepresentations.Labelmap,
  },
  {
    renderOutline: false,
  }
);

// Set style for a specific segment
setStyle(
  {
    segmentationId: 'segmentation1',
    type: SegmentationRepresentations.Labelmap,
    segmentIndex: segmentIndex,
  },
  {
    renderFill: false,
  }
);

// Set render inactive segmentations for a viewport
setRenderInactiveSegmentations('viewport1', true);

// Get render inactive segmentations setting for a viewport
const renderInactive = getRenderInactiveSegmentations('viewport1');

// Reset all styles to global
resetToGlobalStyle();
```

  </TabItem>
</Tabs>

---

#### Summary

- **Unified Style Management**: The new `getStyle` and `setStyle` functions provide a unified way to manage segmentation styles across different levelsâ€”global, segmentation-specific, viewport-specific, and segment-specific.
- **Specifier Object**: The `specifier` object allows you to target specific viewports, segmentations, and segments.
  - `type` is required
  - if `segmentationId` is provided, the style will be applied to the specific segmentation representation in all viewports
  - if `segmentationId` and `segmentIndex` are provided, the style will be applied to the specific segment of the specific segmentation representation
  - if `viewportId` is provided, the style will be applied to all segmentations in the specific viewport
  - if `viewportId`, `segmentationId`, and `segmentIndex` are provided, the style will be applied to the specific segment of the specific segmentation in the specific viewport
- **Hierarchy of Styles**: The effective style is determined by a hierarchy that considers global styles, segmentation-specific styles, and viewport-specific styles.

### Active

#### Viewport-based Operations

The API now uses viewport IDs instead of tool group IDs for identifying the context of segmentation operations.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getActiveSegmentationRepresentation(toolGroupId: string);

function getActiveSegmentation(toolGroupId: string);

function setActiveSegmentationRepresentation(
  toolGroupId: string,
  segmentationRepresentationUID: string
);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function getActiveSegmentation(viewportId: string);

function setActiveSegmentation(
  viewportId: string,
  segmentationId: string,
  suppressEvent: boolean = false
);
```

  </TabItem>
</Tabs>

#### Migration Steps:

1. Replace all instances of `toolGroupId` with `viewportId` in function calls.
2. Update `getActiveSegmentationRepresentation` and `getActiveSegmentation` calls to use the new `getActiveSegmentation` function.
3. Replace `setActiveSegmentationRepresentation` calls with `setActiveSegmentation`, using the new parameter structure.

#### Return Type Changes

The return type of `getActiveSegmentation` has changed from an implicit `undefined` to an explicit `Segmentation` type.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getActiveSegmentation(toolGroupId: string);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function getActiveSegmentation(viewportId: string): Segmentation;
```

  </TabItem>
</Tabs>

#### Migration Steps:

1. Replace all calls to `getActiveSegmentationRepresentation` with `getActiveSegmentation`.
2. Update any code that relied on the `ToolGroupSpecificRepresentation` type to work with the `Segmentation` type instead.

These changes aim to simplify the API and make it more intuitive to use. By focusing on viewport-based operations and removing the distinction between segmentation representations and segmentations, the new API should be easier to work with while maintaining the core functionality of the library.

### Visibility

#### Viewport-Centric Approach

The API now focuses on viewports rather than tool groups, reflecting a shift in the library's architecture.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function setSegmentationVisibility(
  toolGroupId: string,
  segmentationRepresentationUID: string,
  visibility: boolean
): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function setSegmentationRepresentationVisibility(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type?: SegmentationRepresentations;
  },
  visibility: boolean
): void {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `toolGroupId` with `viewportId` in function calls.
2. Use a `specifier` object instead of `segmentationRepresentationUID`.
3. Include `segmentationId` in the `specifier` object.
4. Optionally specify the `type` of segmentation representation.

#### Segmentation Representation Types

Version 2 introduces the concept of segmentation representation types, allowing for more granular control over different representation styles.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getSegmentationVisibility(
  toolGroupId: string,
  segmentationRepresentationUID: string
): boolean | undefined {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function getSegmentationRepresentationVisibility(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type: SegmentationRepresentations;
  }
): boolean | undefined {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update function names from `getSegmentationVisibility` to `getSegmentationRepresentationVisibility`.
2. Replace `toolGroupId` with `viewportId`.
3. Use a `specifier` object with `segmentationId` and `type` instead of `segmentationRepresentationUID`.

#### Segment-Level Visibility Control

The API for controlling individual segment visibility has been updated to align with the new viewport-centric approach.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function setSegmentVisibility(
  toolGroupId: string,
  segmentationRepresentationUID: string,
  segmentIndex: number,
  visibility: boolean
): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function setSegmentIndexVisibility(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type?: SegmentationRepresentations;
  },
  segmentIndex: number,
  visibility: boolean
): void {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update function names from `setSegmentVisibility` to `setSegmentIndexVisibility`.
2. Replace `toolGroupId` with `viewportId`.
3. Use a `specifier` object with `segmentationId` and optional `type` instead of `segmentationRepresentationUID`.

#### New Utility Functions

Version 2 introduces new utility functions for managing segmentation visibility.

```typescript
function getHiddenSegmentIndices(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type: SegmentationRepresentations;
  }
): Set<number> {
  // ...
}
```

This new function allows you to retrieve a set of hidden segment indices for a specific segmentation representation.

#### Removed Functions

The following functions have been removed in version 2:

- `setSegmentsVisibility`
- `getSegmentVisibility`

Replace usage of these functions with the new API methods described above.

<details>
<summary>Why?</summary>

Since the visibility should be set on the representation, and segmentation is not the owner of the visibility, a segmentation can have
two representations with different visibility on each viewport

</details>

### Locking

#### Retrieving Locked Segments

The function to retrieve locked segments has been renamed and its implementation changed:

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getLockedSegments(segmentationId: string): number[] | [];
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function getLockedSegmentIndices(segmentationId: string): number[] | [];
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update all calls from `getLockedSegments` to `getLockedSegmentIndices`.
2. Be aware that the implementation now uses `Object.keys` and `filter` instead of converting a Set to an array.

### Color

#### Viewport-Centric Approach

The API has shifted from a tool group-based approach to a viewport-centric one. This change affects several function signatures and how segmentations are referenced.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function setColorLUT(
  toolGroupId: string,
  segmentationRepresentationUID: string,
  colorLUTIndex: number
): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function setColorLUT(
  viewportId: string,
  segmentationId: string,
  colorLUTsIndex: number
): void {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `toolGroupId` with `viewportId` in function calls.
2. Replace `segmentationRepresentationUID` with `segmentationId`.
3. Update any code that relies on tool group-based segmentation management to use viewport-based management instead.

#### Color LUT Management

The `addColorLUT` function now returns the index of the added color LUT and has an optional `colorLUTIndex` parameter.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex?: number): number {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update calls to `addColorLUT` to handle the returned index if needed.
2. Make the `colorLUTIndex` parameter optional in function calls.

#### Segment Color Retrieval and Setting

The functions for getting and setting segment colors have been renamed and their signatures updated to align with the new viewport-centric approach.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getColorForSegmentIndex(
  toolGroupId: string,
  segmentationRepresentationUID: string,
  segmentIndex: number
): Types.Color {
  // ...
}

function setColorForSegmentIndex(
  toolGroupId: string,
  segmentationRepresentationUID: string,
  segmentIndex: number,
  color: Types.Color
): void {
  // ...
}
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function getSegmentIndexColor(
  viewportId: string,
  segmentationId: string,
  segmentIndex: number
): Types.Color {
  // ...
}

function setSegmentIndexColor(
  viewportId: string,
  segmentationId: string,
  segmentIndex: number,
  color: Types.Color
): void {
  // ...
}
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Rename `getColorForSegmentIndex` to `getSegmentIndexColor`.
2. Rename `setColorForSegmentIndex` to `setSegmentIndexColor`.
3. Update function calls to use `viewportId` instead of `toolGroupId`.
4. Replace `segmentationRepresentationUID` with `segmentationId` in function calls.

### Other Changes

#### Renaming

```js
getSegmentAtWorldPoint-- > getSegmentIndexAtWorldPoint;
getSegmentAtLabelmapBorder-- > getSegmentIndexAtLabelmapBorder;
```

#### getToolGroupIdsWithSegmentation

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function getToolGroupIdsWithSegmentation(segmentationId: string): string[];
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function getViewportIdsWithSegmentation(segmentationId: string): string[];
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Replace `getToolGroupIdsWithSegmentation` with `getViewportIdsWithSegmentation`.

#### Segmentation Representation Management

The way segmentation representations are added, retrieved, and removed has changed significantly.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
function addSegmentationRepresentation(
  toolGroupId: string,
  segmentationRepresentation: ToolGroupSpecificRepresentation,
  suppressEvents?: boolean
): void;

function getSegmentationRepresentationByUID(
  toolGroupId: string,
  segmentationRepresentationUID: string
): ToolGroupSpecificRepresentation | undefined;

function removeSegmentationRepresentation(
  toolGroupId: string,
  segmentationRepresentationUID: string
): void;
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```typescript
function addSegmentationRepresentation(
  viewportId: string,
  segmentationRepresentation: SegmentationRepresentation,
  suppressEvents?: boolean
): void;

function getSegmentationRepresentation(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type: SegmentationRepresentations;
  }
): SegmentationRepresentation | undefined;

function removeSegmentationRepresentation(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type: SegmentationRepresentations;
  },
  immediate?: boolean
): void;
```

  </TabItem>
</Tabs>

**Migration Steps:**

1. Update all calls to `addSegmentationRepresentation` to use `viewportId` instead of `toolGroupId`.
2. Replace `getSegmentationRepresentationByUID` with `getSegmentationRepresentation`, using the new specifier object.
3. Update `removeSegmentationRepresentation` calls to use the new specifier object instead of `segmentationRepresentationUID`.

### PolySEG

#### Import

The PolySEG has been unbundled and placed in a separate external package. To use it, add the `peerImport` function to your `init` function for Cornerstone Core.

```js
async function peerImport(moduleId) {
  if (moduleId === '@icr/polyseg-wasm') {
    return import('@icr/polyseg-wasm');
  }
}

import { init } from '@cornerstonejs/core';

await init({ peerImport });
```

#### Options

You don't need to provide polyseg options for the segmentation representation. It will automatically use PolySeg if the specified representation is unavailable.

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
await segmentation.addSegmentationRepresentations(toolGroupId2, [
  {
    segmentationId,
    type: csToolsEnums.SegmentationRepresentations.Labelmap,
    options: {
      polySeg: {
        enabled: true,
      },
    },
  },
]);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
await segmentation.addSegmentationRepresentations(viewportId2, [
  {
    segmentationId,
    type: csToolsEnums.SegmentationRepresentations.Labelmap,
  },
]);
```

  </TabItem>
</Tabs>

#### Actor UID for labelmaps

The way the actorUID is generated has changed to use a combination of segmentationId and SegmentationRepresentations.Labelmap.
<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```js
const volumeInputs: Types.IVolumeInput[] = [
  {
    volumeId: labelMapData.volumeId,
    actorUID: segmentationRepresentationUID,
    visibility,
    blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
  },
];
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```js
const volumeInputs: Types.IVolumeInput[] = [
  {
    volumeId,
    actorUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,
    visibility,
    blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
  },
];
```

</TabItem>
</Tabs>

We've updated the `actorUID` to `${segmentationId}-${SegmentationRepresentations.Labelmap}`. This change allows us to uniquely identify representations without relying on the `segmentationRepresentationUID`.

For this mean, `getSegmentationActor` is added for you to get the actor for a given labelmap

```ts
export function getSegmentationActor(
  viewportId: string,
  specifier: {
    segmentationId: string;
    type: SegmentationRepresentations;
  }
): Types.VolumeActor | Types.ImageActor | undefined;
```

### New Utilities

`clearSegmentValue` is added to clear a specific segment value in a segmentation,
it will make the segment value to 0

```js
 function clearSegmentValue(
  segmentationId: string,
  segmentIndex: number
)
```

## Renaming and Nomenclature

### Types

PointsManager is now IPointsManager

migration

```js
import { IPointsManager } from '@cornerstonejs/tools/types';
```

### Units

#### getCalibratedLengthUnitsAndScale Signature

It is highly unlikely that you were using this function directly, but if you were, here's the migration
The return type of the function has changed slightly, with `units` and `areaUnits` renamed to `unit` and `areaUnit` respectively.

<Tabs>
<TabItem value="Before" label="Before ðŸ“¦ " default>

```typescript
const getCalibratedLengthUnitsAndScale = (image, handles) => {
  // ...
  return { units, areaUnits, scale };
};
```

</TabItem>
<TabItem value="After" label="After ðŸš€">

```typescript
const getCalibratedLengthUnitsAndScale = (image, handles) => {
  // ...
  return { unit, areaUnit, scale };
};
```

</TabItem>
</Tabs>

#### getModalityUnit -> getPixelValueUnits

To make more sense

<details>
<summary>Why?</summary>
There was too much inconsistency in the units used throughout the library. We had `unit`, `areaUnits`, `modalityUnit`, and various others. Now, we have consolidated these units. You need to update your codebase to reflect the new unit system if you are hydrating annotations for Cornerstone3D.

In addition modalityUnit is now pixelValueUnits to reflect the correct term, since for a single modality there can be multiple pixel values (e.g, PT SUV, PT RAW, PT PROC)

</details>

### BasicStatsCalculator

the option `noPointsCollection` has been renamed to `storePointData`

### getSegmentAtWorldPoint -> getSegmentIndexAtWorldPoint

### getSegmentAtLabelmapBorder -> getSegmentIndexAtLabelmapBorder

---

## Others

### roundNumber

The utility has been relocated from `@cornerstonejs/tools` utilities to `@cornerstonejs/core/utilities`.
migration

```js
import { roundNumber } from '@cornerstonejs/core/utilities';
```

### pointInShapeCallback

### 1. New Import Path

The `pointInShapeCallback` function has been moved. Update your imports as follows:

```js
import { pointInShapeCallback } from '@cornerstonejs/core/utilities';
```

### 2. Updated Usage

The function signature has changed to use an options object for improved clarity and flexibility. Below is a guide to how the usage has changed.

**Old Usage:**

```js
const pointsInShape = pointInShapeCallback(
  imageData,
  shapeFnCriteria,
  (point) => {
    // callback logic for each point
  },
  boundsIJK
);
```

**New Usage:**

```js
const pointsInShape = pointInShapeCallback(imageData, {
  pointInShapeFn: shapeFnCriteria,
  callback: (point) => {
    // callback logic for each point
  },
  boundsIJK: boundsIJK,
  returnPoints: true, // Optionally, to return the points inside the shape
});
```

### Key Changes:

- **Options Object**: Configuration parameters such as `pointInShapeFn`, `callback`, `boundsIJK`, and `returnPoints` are now passed through an options object.
- **Return Points**: Use the `returnPoints` option to specify if you want to return the points within the shape, previously it was always returning the points. If you relied on returning points directly, make sure to include `storePointData: true` in the tool options when you active it

// <----------------------------------------------------------->

# @cornerstonejs/dicom-image-loader

## Initialization and Configuration

**Before:**

```javascript
cornerstoneDICOMImageLoader.external.cornerstone = cornerstone;
cornerstoneDICOMImageLoader.external.dicomParser = dicomParser;
cornerstoneDICOMImageLoader.configure({
  useWebWorkers: true,
  decodeConfig: {
    convertFloatPixelDataToInt: false,
    use16BitDataType: preferSizeOverAccuracy || useNorm16Texture,
  },
});

// Additional configuration...
cornerstoneDICOMImageLoader.webWorkerManager.initialize(config);
```

**After:**

```javascript
cornerstoneDICOMImageLoader.init();

// optionally you can pass a config object to init
cornerstoneDICOMImageLoader.init({
  maxWebWorkers: 2, //
});
```

**Migration Guide:**

1. You should replace configure with `init`
2. You don't need to pass cornerstone and dicomParser anymore, we just use them internally and import them as dependencies
3. Remove `useWebWorkers` option as web workers are now always used.
4. Remove `decodeConfig` options as they are no longer applicable.
5. Remove separate `webWorkerManager.initialize` call as it's now handled internally.
6. Set `maxWebWorkers` in the configure options instead of a separate config object.
   1. by default we set half of the available cores

### Removal of External Module

The `externalModules` file has been removed. Any code relying on `cornerstone.external` should be updated to use direct imports or the new configuration method.
We just treat the cornerstonejs/core and dicomparser as any other dependency and import them directly internally

### Webpack Configuration

Remove the following Webpack rule if present in your configuration:

```json
{
  test: /\.worker\.(mjs|js|ts)$/,
  use: [
    {
      loader: 'worker-loader',
    },
  ],
},
```

Web workers are now handled internally by the library.

## Always `Prescale`

By default, Cornerstone3D always prescales images with the modality LUT (rescale slope and intercept). You probably don't need to make any changes to your codebase.

<details>
<summary>Why?</summary>
The viewport previously made the decision to prescale, and all viewports followed this approach. However, we found prescaling bugs in some user-implemented custom image loaders. We have now fixed these issues by consistently applying prescaling.

</details>

## Decoders Update

`@cornerstonejs/dicomImageLoader` previously utilized the old API for web workers, which is now deprecated. It has transitioned to the new web worker API via our new internal wrapper over `comlink` package. This change enables more seamless interaction with web workers and facilitates compiling and bundling the web workers to match the ESM version of the library.

<details>
<summary>Why?</summary>

To consolidate the web worker API using a new ES module format, which will enable new bundlers like `vite` to work seamlessly with the library.

</details>

So if you had custom logic in your webpack or other bundler you can remove the following rule

```json
{
  test: /\.worker\.(mjs|js|ts)$/,
  use: [
    {
      loader: 'worker-loader',
    },
  ],
},
```

## Removing support for non web worker decoders

We have removed support for non-web worker decoders in the 2.0 version of the cornerstone3D. This change is to ensure that the library is more performant and to reduce the bundle size.

<details>
<summary>Why?</summary>

We see no compelling reason to use non-worker decoders anymore. Web worker decoders offer superior performance and better compatibility with modern bundlers.

</details>

## Removal of `minAfterScale` and `maxAfterScale` on `imageFrame`

in favor of `smallestPixelValue` and `largestPixelValue`, previously they were 4 all used together and was
making it hard to use the correct one.

## DICOM Image Loader ESM default

We have changed the default export of the DICOM Image Loader to ESM in the 2.0 version of the cornerstone3D and correctly
publish types

This mean you don't need to have an alias for the dicom image loader anymore

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

Probably in your webpack or other bundler you had this

```js
 alias: {
  '@cornerstonejs/dicom-image-loader':
    '@cornerstonejs/dicom-image-loader/dist/dynamic-import/cornerstoneDICOMImageLoader.min.js',
},
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

Now you can remove this alias and use the default import

  </TabItem>
</Tabs>

<details>
<summary>Why?</summary>

ESM is the future of javascript, and we want to ensure that the library is compatible with modern bundlers and tools.

</details>

---

# `@cornerstonejs/nifti-image-volume-loader`

After migrating to the new pixel data model for volumes, we have also updated the Nifti image volume loader to align with this model.

This change brings the loader more in line with the Cornerstone3D API and the rest of the library. We now have a dedicated Nifti image loader (not a volume loader) for loading Nifti files, creating a more consistent API across all image loaders in the library.

A significant improvement is the ability to use stack viewports for Nifti files. You no longer need volume viewports to render Nifti files (though you can still use volume viewports).

<details>
<summary>Why?</summary>

The process now involves calling the Nifti URL and parsing the first bytes of the file (via stream decoding) to obtain metadata. We then create imageIds based on this metadata and use them to create the volume.

This approach shifts from our previous volume-first method to an imageId-first approach, aligning with the rest of the Cornerstone3D API.

</details>

<Tabs>
  <TabItem value="Before" label="Before ðŸ“¦ " default>

```js
const niftiURL =
  'https://ohif-assets.s3.us-east-2.amazonaws.com/nifti/MRHead.nii.gz';
const volumeId = 'nifti:' + niftiURL;

const volume = await volumeLoader.createAndCacheVolume(volumeId);

setVolumesForViewports(
  renderingEngine,
  [{ volumeId }],
  viewportInputArray.map((v) => v.viewportId)
);
```

  </TabItem>
  <TabItem value="After" label="After ðŸš€ðŸš€">

```js
import {
  cornerstoneNiftiImageLoader,
  createNiftiImageIdsAndCacheMetadata,
} from '@cornerstonejs/nifti-volume-loader';

const niftiURL =
  'https://ohif-assets.s3.us-east-2.amazonaws.com/nifti/CTACardio.nii.gz';

// register the image loader for nifti files
imageLoader.registerImageLoader('nifti', cornerstoneNiftiImageLoader);

// similar to the rest of the cornerstone3D image loader
const imageIds = await createNiftiImageIdsAndCacheMetadata({ url: niftiURL });

// For stack viewports
viewport.setStack(imageIds);

// for volume viewports
const volume = await volumeLoader.createAndCacheVolume(volumeId, {
  imageIds,
});

await volume.load();
setVolumesForViewports(
  renderingEngine,
  [{ volumeId }],
  viewportInputArray.map((v) => v.viewportId)
);
```

  </TabItem>
</Tabs>

---

# Developer Experience

### Dependency Cycles

We have removed all dependency cycles in the library, ensuring it is now free of any such issues. To maintain this, we have added rules in our linters that will catch any dependency cycles in pull requests during continuous integration. Additionally, you can run `yarn run format-check` to ensure that the formatting is correct and to check for dependencies as well.

### Published APIs

We have now published the APIs for the DICOM Image Loader and Nifti Volume Loader. So in creating your PRs don't forget to run `yarn run build:update-api` and include the generated files in your PR.

### Karma tests

There has been a lot of work to clean up tests let's dive in

#### Setup and Cleanup

Before, we had scattered logic:

```js
beforeEach(function () {
  csTools3d.init();
  csTools3d.addTool(BidirectionalTool);
  cache.purgeCache();
  this.DOMElements = [];
  this.stackToolGroup = ToolGroupManager.createToolGroup('stack');
  this.stackToolGroup.addTool(BidirectionalTool.toolName, {
    configuration: { volumeId: volumeId },
  });
  this.stackToolGroup.setToolActive(BidirectionalTool.toolName, {
    bindings: [{ mouseButton: 1 }],
  });

  this.renderingEngine = new RenderingEngine(renderingEngineId);
  imageLoader.registerImageLoader('fakeImageLoader', fakeImageLoader);
  volumeLoader.registerVolumeLoader('fakeVolumeLoader', fakeVolumeLoader);
  metaData.addProvider(fakeMetaDataProvider, 10000);
});

afterEach(function () {
  csTools3d.destroy();
  cache.purgeCache();
  eventTarget.reset();
  this.renderingEngine.destroy();
  metaData.removeProvider(fakeMetaDataProvider);
  imageLoader.unregisterAllImageLoaders();
  ToolGroupManager.destroyToolGroup('stack');

  this.DOMElements.forEach((el) => {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  });
});
```

Now it's centralized:

```js
beforeEach(function () {
  const testEnv = testUtils.setupTestEnvironment({
    renderingEngineId,
    toolGroupIds: ['default'],
    viewportIds: [viewportId],
    tools: [BidirectionalTool],
    toolConfigurations: {
      [BidirectionalTool.toolName]: {
        configuration: { volumeId: volumeId },
      },
    },
    toolActivations: {
      [BidirectionalTool.toolName]: {
        bindings: [{ mouseButton: 1 }],
      },
    },
  });
  renderingEngine = testEnv.renderingEngine;
  toolGroup = testEnv.toolGroups['default'];
});

afterEach(function () {
  testUtils.cleanupTestEnvironment({
    renderingEngineId,
    toolGroupIds: ['default'],
  });
});
```

<details>
<summary>Why?</summary>

It was causing many issues with timeout and race conditions.

</details>

#### Viewport Creation

We've centralized the previously repeated logic for viewport creation into one place.

```js
const element = testUtils.createViewports(renderingEngine, {
  viewportId,
  viewportType: ViewportType.STACK,
  width: 512,
  height: 128,
});
```

#### Image Id

Previously, for the fake image loader, you should have used:

```js
const imageId1 = 'fakeImageLoader:imageURI_64_64_10_5_1_1_0';
```

This string encoded various parameters. Now, it has been restructured into an object for better clarity:

```js
const imageInfo1 = {
  loader: 'fakeImageLoader',
  name: 'imageURI',
  rows: 64,
  columns: 64,
  barStart: 32,
  barWidth: 5,
  xSpacing: 1,
  ySpacing: 1,
  sliceIndex: 0,
};

const imageId1 = testUtils.encodeImageIdInfo(imageInfo1);
```

same exists for volumeId

```js
const volumeId = testUtils.encodeVolumeIdInfo({
  loader: 'fakeVolumeLoader',
  name: 'volumeURI',
  rows: 100,
  columns: 100,
  slices: 4,
  xSpacing: 1,
  ySpacing: 1,
  zSpacing: 1,
});
```
